<html>
	<head>
		<script src=https://teikn-js.googlecode.com/svn-history/r23/trunk/libraries/kinetic-v3.6.0.js></script>
		<script>	
			/*****
			* unbound array of the hexagon object, basically the main object in the game
			* 
			* defined with: new Kinetic.Shape(function(hexagonOrigColor, hexagonColor, hexagonColorHover, coordX, coordY, hexagonOn, hoverOn){});
			* 
			* attributes:
			* .hexagonOrigColor = string from the 'colors' array, initial color of hex, at the beginning of the game
			* .hexagonColor = string from the 'colors' array, can change to black
			* .hexagonColorHover = string from the 'colorsHover' array, slightly lighter than normal colors, used to show which hexes will be destroyed with current color selection
			* .coordX = integer between 0 and gridSize, gets offset by 1 every odd row
			* .coordY = integer between 0 and gridSize
			* .hexagonOn = string, can be "ON", "OFF", or "OFF_TEMP". "OFF" means the hexagon has been eliminated, "ON" - still in play, "TEMP_OFF" - used by AI for next turn calculation, but is then set back to "ON"
			* .hoverOn = string, can be "ON" or "OFF", "ON" - hexagon color is currently in hover/slightly lighter color mode, "OFF" - hexagon color is not hovered over
			* 
			*/		
			var hexagon = [];

			//I don't remember what it does, should look it up and update this comment..
			var movesCounted = "ON";

			//number of moves used during this game
			var moves = 0;
			//current score
			var score = 0;
			//initial score that (scorePerMove * moves) will be subtracted from
			var scoreInitial = 300;
			//score lost per each move
			var scorePerMove = 10;

			//string literals of colors used in the game
			var colors = ["red", "orange", "gold", "darkgreen", "lightblue", "mediumblue", "purple", "black"];
			//string literals of colors used in the game, hover mode
			var colorsHover = ["coral", "sandybrown", "yellow", "limegreen", "cyan", "dodgerblue", "mediumorchid", "black"];

			//drawing layer for shapes
			var shapesLayer = new Kinetic.Layer();
			//drawing layer for messages, I don't remember how I use it
			var messageLayer = new Kinetic.Layer();

			//since hex elimination happens differently for the very first hex, we need to know if it's the first turn
			//as I was typing this comment, I realized I could just use (moves) variables, but it still seems a good idea to have a separate var
			var firstTurn = true;
			//first turn variable, but for AI mode
			var firstTurnAI = true;	
				
			/*****
			* unbound array containing all cluster objects
			* new global var for AI: cluster, used for storing data about clusters
			*
			* this.ID = cIndex;
			* this.color = thisHex.hexagonColor;
			*						
			* this.minX = thisHex.coordX;
			* this.maxX = thisHex.coordX;
			* this.avgX = thisHex.coordX;
			*					
			* this.minY = thisHex.coordY;
			* this.maxY = thisHex.coordY;
			* this.avgY = thisHex.coordY;
			*					
			* this.size = 1;
			* 
			*****/
			var cluster = [];
			// is this a human or NPC player
			var NPC = false;
			
			
			/// write to file
			var filepath = "file:///Users/admin/Downloads/hexalated_neural.txt";
			var output = "";

			////////////////////////////////////////////////////
			/**
			 * writeTextFile write data to file on hard drive
			 * @param  string  filepath   Path to file on hard drive
			 * @param  sring   output     Data to be written
			 */
			function writeTextFile(/*filepath, output*/) {
				var txtFile = new File(filepath);
				txtFile.open("w"); //
				txtFile.writeln(output);
				txtFile.close();
			}

			////////////////////////////////////////////////////
			/**
			 * readTextFile read data from file
			 * @param  string   filepath   Path to file on hard drive
			 * @return string              String with file data
			 */
			function readTextFile(/*filepath*/) {
				var str = "";
				var txtFile = new File(filepath);
				txtFile.open("r");
				while (!txtFile.eof) {
					// read each line of text
					str += txtFile.readln() + "\n";
				}
				txtFile.close();
				return str;
			}

			////////////////////////////////////////////////////

			// Great parse examples with result to process file
			// http://www.w3schools.com/jsref/jsref_parseint.asp
			// var a = parseInt("10");           // 10
			// var b = parseInt("10.00");        // 10
			// var c = parseInt("10.33");        // 10
			// var d = parseInt("34 45 66");     // 34
			// var e = parseInt(" 60 ");         // 60
			// var f = parseInt("40 years");     // 40
			// var g = parseInt("He was 40");    // NaN
			//
			// var h = parseInt("10",10);        // 10
			// var i = parseInt("010");          // 10
			// var j = parseInt("10",8);         // 8
			// var k = parseInt("0x10");         // 16
			// var l = parseInt("10",16);        // 16

			// http://www.w3schools.com/jsref/jsref_parsefloat.asp
			// var a = parseFloat("10");         // 10
			// var b = parseFloat("10.00");      // 10
			// var c = parseFloat("10.33");      // 10.33
			// var d = parseFloat("34 45 66");   // 34
			// var e = parseFloat(" 60 ");       // 60
			// var f = parseFloat("40 years");   // 40
			// var g = parseFloat("He was 40");  // NaN


//neural network
/*			function train(iterations){
			var X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ]);
			var y = np.array([[0,1,1,0]]).T;
			var syn0 = 2*np.random.random((3,4)) - 1;
			var syn1 = 2*np.random.random((4,1)) - 1;
			for (var j = 0; j < iterations; j++){
				l1 = 1/(1+np.exp(-(np.dot(X,syn0))))
				l2 = 1/(1+np.exp(-(np.dot(l1,syn1))))
				l2_delta = (y - l2)*(l2*(1-l2))
				l1_delta = l2_delta.dot(syn1.T) * (l1 * (1-l1))
				syn1 += l1.T.dot(l2_delta)
				syn0 += X.T.dot(l1_delta)
			}
*/
			//  input: color
			// output: total amount of that color remaining on the board
			function get_number_of_color_remaining(cColor){
				var count = 0;
			
				for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
					if (cHexagon.hexagonColor == cColor) {
						if (cHexagon.hexagonOn == "ON") {
							count++;
						}
					}
				}
				return count;
			}

			//  input: color
			// output: total amount of that color affected if this color is clicked next
			function get_number_of_color_affected(cColor){
				var count = 0;
				var repeat = true;
				
				while (repeat == true) {
					repeat = false;
					for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
						if (blackHexagon.hexagonOn == "OFF" || blackHexagon.hexagonOn == "OFF_TEMP") {
							for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
								var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == cColor && cHexagon.hexagonOn == "ON") {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
										//set hex to OFF temporarily, to simulate this hex being eliminated
										//to calculate a chain reaction
										cHexagon.hexagonOn = "OFF_TEMP";
										count++;
										repeat = true;
									}
								}
							}
						}
					}
				}
				
				//return all hexes temporarily set to OFF back to ON
				for (var a = 0, cHexagon; cHexagon = hexagon[a]; a++) {
					if (cHexagon.hexagonOn == "OFF_TEMP") {
						cHexagon.hexagonOn = "ON";
					}
				}
				return count;
			}

			//  input: color
			// output: set of coordinates of the affected area is this color is clicked on next
			function get_affected_coords(cColor){
				var coords = [ , ];
				var repeat = true;
				
				while (repeat == true) {
					repeat = false;
					for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
						if (blackHexagon.hexagonOn == "OFF") {
							for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
								var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == cColor) {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
										coords.append(cHexagon.coordx, cHexagon.coordY);
										repeat = true;
									}
								}
							}
						}
					}
				}
				return coords;
			}

			//  input: color
			// output: average center coordinates of the affected area is this color is clicked on next
			function get_affected_center(cColor){
				var coords = get_affected_coords(cColor);
				var avg_coords = [2];
				
				var x_min = 10000;
				var x_max = 0;
				var y_min = 10000;
				var y_max = 0;
				var x_avg = 0;
				var y_avg = 0;
				
				for (var a = 0, cHexagon; cHexagon = hexagon[a]; a++) {
					if (cHexagon.coordX < x_min) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordX > x_max) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordY < y_min) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordY > y_max) {
						x_min = cHegaxon.coordX;
					}
				}
				
				x_avg = (x_min + x_max) / 2;
				y_avg = (y_min + y_max) / 2;
				
				avg_coords(0) = x_avg;
				avg_coords(1) = y_avg;

				return avg_coords;
			}

			//    input: none
			//   output: none
			// function: create a set of clusters (global var cluster), the sum of which contains every hex on the board
			function define_clusters(){
				for (var a = 0, thisHex; thisHex = hexagon[a]; a++) {
					//if the current hex is not yet part of an existing cluster, instantiate new cluster
					if (thisHex.clusterID == -1){
						var cIndex = cluster.length;
					
						cluster[cIndex] = new function(ID, color, minX, maxX, avgX, minY, maxY, avgY, size) {
								this.ID = cIndex;
								this.color = thisHex.hexagonColor;
								
								this.minX = thisHex.coordX;
								this.maxX = thisHex.coordX;
								this.avgX = thisHex.coordX;
								
								this.minY = thisHex.coordY;
								this.maxY = thisHex.coordY;
								this.avgY = thisHex.coordY;
								
								this.size = 1;
						};
						thisHex.clusterID = cIndex;
					}					
					var cID = thisHex.clusterID;
					
					//cycle through all hexes to find nearby one
					for (var b = 0, thatHex; thatHex = hexagon[b]; b++) {
						//only look at that hex if it's not yet part of a cluster	
						if (thatHex.clusterID == -1) {
							//offset the X coord for every other row, due to the hex grid layout
							var xCoordOffset = thisHex.coordY%2 == 0 ? -1 : 1;
							//if the second hex is the same color as the original hex
							if (thatHex.hexagonColor == thisHex.hexagonColor) {
								//check if these hexes are adjacent
								if (hexesAreAdjacent(thisHex, thatHex, xCoordOffset)) {
									thatHex.clusterID = cID;
									cluster[cID].size++;
									
									cluster.maxX = thatHex.coordX > cluster.maxX ? thatHex.coordX : cluster.maxX;
									cluster.minX = thatHex.coordX < cluster.minX ? thatHex.coordX : cluster.minX;
									
									cluster.maxY = thatHex.coordY > cluster.maxY ? thatHex.coordY : cluster.maxY;
									cluster.minY = thatHex.coordY < cluster.minY ? thatHex.coordY : cluster.minY;
									
									cluster.avgX = (cluster.minX + cluster.maxX) / 2;
									cluster.avgY = (cluster.minY + cluster.maxY) / 2;
								}
							}	
						}		
					}
				}
			}
			
			function AINewGame(){
				NPC = true;
				NewGame();
				define_clusters();
				firstMove("MAX_HEX");
			}
			
			function firstMove(mode){
				var nextColor = "";
				
				switch (mode) {
					case "RANDOM":
						var randomHex = Math.floor(Math.random() * hexagon.length);
						
						simulateMouseDown(hexagon[randomHex], true); 
					break;
					case "MAX_HEX":
						var maxSize = 0;
						
						for (var a = 0, c; c = cluster[a]; a++){	
							if (c.size > maxSize){
								maxSize = c.size;
								maxCluster = c.ID;
							}						
						}
						
						for (var a = 0, h; h = hexagon[a]; a++) {
							if (h.clusterID == maxCluster){
								simulateMouseDown(h, true);
							}
						}
					break;
					case "MOST_LEFT":
						var mostLeft = 0;
						
					break;
					case "MOST_CENTERED:":
						//
					break;
				}
				//nextMove(mode, "HOVER");
			}
			
			function nextMove(mode, action){
				var nextColor = "";
				 
				switch (mode) {
					case "RANDOM":
						var randomColor = Math.floor(Math.random() * 6);
						
						nextColor = colors[randomColor];
					break;
					case "MAX_HEX":
						var maxCount = 0;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentCount = get_number_of_color_affected(colors[a]);
							
							if (currentCount > maxCount) {
								maxCount = currentCount;
								nextColor = colors[a];
							}
						}
					break;
					case "MOST_LEFT":
						var mostLeft = 0;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentCount = get_number_of_color_remaining(colors[a]);
							
							if (currentCount > mostLeft) {
								mostLeft = currentCount;
								nextColor = colors[a];
							}
						}
						alert (nextColor);
					break;
					case "MOST_CENTERED":
						var gridSize = parseFloat(document.getElementById("txtGridSizeID").value);//20;	
						var mostCentered = 10000;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentX = get_affected_center(colors[a])[0];
							var currentY = get_affected_center(colors[a])[1];
							//crude distance from center
							var distance = Math.abs((gridSize / 2) - currentX) + Math.abs((gridSize / 2) - currentY)
							
							if (distance < mostCentered) {
							
								mostCentered = distance;
								nextColor = colors[a];
							}
						}
						alert (nextColor);					
					break;	
				}
				for (var a = 0, h; h = hexagon[a]; a++) {
					if (h.hexagonColor == nextColor){
						if (action == "CLICK") {
							simulateMouseDown(h, true);
						}
						if (action == "HOVER") {
							simulateMouseOver(h, true);
						}
					}
				}
			}
			
//end neural network
	
			function hexesAreAdjacent(bHexagon, cHexagon, xCoordOffset) {
				if ((cHexagon.coordY == bHexagon.coordY - 1 && cHexagon.coordX == bHexagon.coordX + 0) ||
					(cHexagon.coordY == bHexagon.coordY - 1 && cHexagon.coordX == bHexagon.coordX + xCoordOffset) ||
					(cHexagon.coordY == bHexagon.coordY + 0 && cHexagon.coordX == bHexagon.coordX - 1) ||
					(cHexagon.coordY == bHexagon.coordY + 0 && cHexagon.coordX == bHexagon.coordX + 1) ||
					(cHexagon.coordY == bHexagon.coordY + 1 && cHexagon.coordX == bHexagon.coordX + 0) ||
					(cHexagon.coordY == bHexagon.coordY + 1 && cHexagon.coordX == bHexagon.coordX + xCoordOffset)) {
					return true;	
				}
				return false;
			}

			function writeMessage(messageLayer, message){
				var context = messageLayer.getContext();
				messageLayer.clear();
				context.font = "18pt Calibri";
				context.fillStyle = "black";
				context.fillText(message, 10, 25);
			}

//////////////////////////////////////////////////////////////////
//																//
// Check if there are any hexes of same color that are adjacent //
//																//																//
//////////////////////////////////////////////////////////////////

			function eliminateHexes(vOrigColor, mouseAction){
				var repeat = false;
				for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
					if (blackHexagon.hexagonOn == "OFF") {
						for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
							var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == vOrigColor) {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
									switch (mouseAction) {
										case "DOWN":
											cHexagon.hexagonColor = "black";
											cHexagon.hoverOn = "OFF";
											cHexagon.hexagonOn = "OFF";
											repeat = true;
											if (movesCounted == "OFF") {
												moves++;
												movesCounted = "ON";
												score = moves * scorePerMove >= scoreInitial ? 0 : scoreInitial - scorePerMove * moves;
											}
										break;
										case "OVER":
											cHexagon.hexagonColor = cHexagon.hexagonColorHover;
											cHexagon.hoverOn = "ON";
											cHexagon.hexagonOn = "OFF";
											repeat = true;		      						
										break;
										case "OUT":
											for (var c = 0, hoverHexagon; hoverHexagon = hexagon[c]; c++) {
												if (hoverHexagon.hoverOn == "ON") {
													hoverHexagon.hexagonColor = hoverHexagon.hexagonOrigColor;
													hoverHexagon.hoverOn = "OFF";
													hoverHexagon.hexagonOn = "ON";
												}
											}			      						
										break;
									}
								}
							}
						}
					}
				}
				movesCounted = "ON";
				return repeat;
			}

			function clippedBackgroundImage(ctx, img, w, h, X, Y, hover){
			  var imgHeight = w / img.width * img.height;
			  
			  ctx.save(); // Save the context before clipping
			  ctx.clip(); // Clip to whatever path is on the context

			  if (hover == "ON") {
				ctx.globalAlpha = 0.4;
			  }
			  
			  if (imgHeight < h){
				ctx.fillStyle = '#000';
				ctx.fill();
			  }
			  
			  ctx.drawImage(img,X,Y,w,imgHeight);
			  ctx.restore(); // Get rid of the clipping region
			}

			window.onload = function(){
				//NewGame();
			};

			function NewGame(){
				//hide settings input once the game begins
				document.getElementById("settings").style.display = 'none';

				//grid size, square, from user input before the game
				var gridSize = parseFloat(document.getElementById("txtGridSizeID").value);//20;	
				//size of each hexagon on the screen
				var hexSideLength = parseFloat(document.getElementById("txtHexSizeID").value);//15;
				//constants to figure out hexagon math
				var hexAngleX = 45;
				var hexAngleY = 45;	
				//constants determining length of half a hexagon
				var halfHexagonX = hexSideLength * Math.sin(hexAngleX);
				var halfHexagonY = hexSideLength * Math.cos(hexAngleY) + hexSideLength;
				//size of the drawing canvas, from min/max coords of hex grid
				var stage = new Kinetic.Stage("container", halfHexagonX * (gridSize + 1) * 2, halfHexagonY * (gridSize + 1));
				//array container for textures
				var imgArray = [];
				//container for images used for rendering
				var img = Object;

				var e = document.getElementById("container");
				e.style.width = halfHexagonX * (gridSize + 1) * 2;
				e.style.height = halfHexagonY * (gridSize + 1);

				/////////////////////////////////////////// TEXTURES            
				
				//URL string literals for texture images
				var textureURL = [
					"https://cloud.githubusercontent.com/assets/13951475/9512939/d18a28b0-4c3d-11e5-9c6d-c5a02d954b24.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512941/d199c842-4c3d-11e5-9b24-55df76b44ade.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512936/d187b9b8-4c3d-11e5-88c0-f8a23ed09f5d.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512935/d1878178-4c3d-11e5-816d-cb900d776ee1.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512937/d18843a6-4c3d-11e5-976d-2badc7ad5f34.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512940/d18a4af2-4c3d-11e5-9512-e498bb87d37c.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512938/d1894828-4c3d-11e5-9d07-f86ea8294054.png",
					"https://cloud.githubusercontent.com/assets/13951475/9512942/d19d1844-4c3d-11e5-905b-3502f962aaab.png"
				];
				
				//create img objects for textures
				for (a = 0; a < 8; a++) {
					//create new image object
					imgArray[a] = new Image();
					//empty initializer
					imgArray[a].onload = function() {
						// Now you can pass the `img` object to various functions
					};           
					//assign image source to a URL
					imgArray[a].src = textureURL[a];					
				}
							/*
				var img0=new Image();
				//empty initializer
				img0.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img0.src="https://cloud.githubusercontent.com/assets/13951475/9512939/d18a28b0-4c3d-11e5-9c6d-c5a02d954b24.png";

				var img1=new Image();
				//empty initializer
				img1.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img1.src="https://cloud.githubusercontent.com/assets/13951475/9512941/d199c842-4c3d-11e5-9b24-55df76b44ade.png";
							
				var img2=new Image();
				//empty initializer
				img2.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img2.src="https://cloud.githubusercontent.com/assets/13951475/9512936/d187b9b8-4c3d-11e5-88c0-f8a23ed09f5d.png";

				var img3=new Image();
				//empty initializer
				img3.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img3.src="https://cloud.githubusercontent.com/assets/13951475/9512935/d1878178-4c3d-11e5-816d-cb900d776ee1.png";

				var img4=new Image();
				//empty initializer
				img4.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img4.src="https://cloud.githubusercontent.com/assets/13951475/9512937/d18843a6-4c3d-11e5-976d-2badc7ad5f34.png";

				var img5=new Image();
				//empty initializer
				img5.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img5.src="https://cloud.githubusercontent.com/assets/13951475/9512940/d18a4af2-4c3d-11e5-9512-e498bb87d37c.png";

				var img6=new Image();
				//empty initializer
				img6.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img6.src="https://cloud.githubusercontent.com/assets/13951475/9512938/d1894828-4c3d-11e5-9d07-f86ea8294054.png";

				var imgSpace=new Image();
				//empty initializer
				imgSpace.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				imgSpace.src="https://cloud.githubusercontent.com/assets/13951475/9512942/d19d1844-4c3d-11e5-905b-3502f962aaab.png";
				*/
				////////////////////////////////////////////////////

				for (var m = 0; m < gridSize; m++) {
					for (var n = 0; n < gridSize; n++) {
						(function(){
							var i = n;
							var j = m;
							var randomColor = Math.floor(Math.random() * 7);

							hexagon[m * gridSize + n] = new Kinetic.Shape(function(hexagonOrigColor, hexagonColor, hexagonColorHover, coordX, coordY, hexagonOn, hoverOn){     
								var canvas = this.getCanvas();
								var context = this.getContext();  

								//this.hexagonOn = typeof(this.hexagonOn) != 'undefined' ? this.hexagonOn : "ON";
								//this.hoverOn = typeof(this.hoverOn) != 'undefined' ? this.hoverOn : "OFF";

								if (j%2 == 0) {
									var hexStartX = halfHexagonX + halfHexagonX * 2 * i;
								}
								else {
									var hexStartX = halfHexagonX * 2 + halfHexagonX * 2 * i;
								}       
								
								var hexStartY = halfHexagonY * j;

								this.coordX = i;
								this.coordY = j;
								
								this.clusterID = -1;
								
								if (this.hexagonColor != "black") {
									img = imgArray[randomColor];
									/*
									switch (randomColor) {
										case 0:
											img = img0;
											break;
										case 1:
											img = img1;
											break;
										case 2:
											img = img2;
											break;
										case 3:
											img = img3;
											break;
										case 4:
											img = img4;
											break;
										case 5:
											img = img5;
											break;
										case 6:
											img = img6;
											break;
										
									}
									*/
									this.hexagonColor = colors[randomColor];
									this.hexagonColorHover = colorsHover[randomColor];
									this.hexagonOrigColor = this.hexagonColor;
									this.hexagonOn = "ON";
								}
								else {
									this.hexagonColor = colors[7];
									this.hexagonColorHover = colorsHover[7];
								}				
										
								context.save;
								
								context.beginPath();
								context.lineWidth = 2;
								context.strokeStyle = this.hexagonOn != "OFF" ? "black" : "indigo";
								//context.fillStyle = this.hoverOn != "ON" ? this.hexagonColor : this.hexagonColorHover;
								context.moveTo(hexStartX, hexStartY);
								context.lineTo(hexStartX + hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY));
								context.lineTo(hexStartX + hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY) + hexSideLength);
								context.lineTo(hexStartX, hexStartY + hexSideLength * Math.cos(hexAngleY) * 2 + hexSideLength);
								context.lineTo(hexStartX - hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY) + hexSideLength);
								context.lineTo(hexStartX - hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY));
								context.closePath();
								
								var textureImg = Object;
								
								//if hexagon is not OFF (aka ON) OR hover is ON, display texture
								if (this.hexagonOn != "OFF" || this.hoverOn == "ON") {
									textureImg = img;
								}
								//otherwise display space background
								else {
									textureImg = imgArray[7];
								}
								clippedBackgroundImage(context, textureImg, halfHexagonX * 2, halfHexagonY * 3 / 2, hexStartX - halfHexagonX, hexStartY, this.hoverOn);
					
								////shapesLayer.fill();
								context.stroke();
								context.restore();
							});

							/*
							hexagon.draggable(true);

							hexagon.on("dragstart", function(){
								hexagon.moveToTop();
								layer.draw();
							}); 
							*/

							//attach a 'on mouse over event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseover", function(){
								//this function funnels both human and computer actions
								simulateMouseOver(this);
							});
					
							//attach a 'on mouse out event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseout", function(){
								//this function funnels both human and computer actions
								simulateMouseOut(this);
							});
													
							//attach a 'on mouse down event' to each hexagon object
							hexagon[m * gridSize + n].on("mousedown", function(){
								//this function funnels both human and computer actions
								simulateMouseDown(this);
							});
										
							//attach a 'on mouse up event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseup", function(){
								//this function funnels both human and computer actions
								simulateMouseUp();
							});
							 
							//add current hexagon to the drawing canvas's shapes layer
							shapesLayer.add(hexagon[m * gridSize + n]);
						})();			
					}
				}		
				stage.add(shapesLayer);
				stage.add(messageLayer);  
				
				//randomFirstMove(); 
			}
			
			
			function simulateMouseOver(h, AIMouseOver) {
				if (!AIMouseOver) {
					//do nothing if player is AI
					//always do else
					if (NPC) {	
						//
					} else {
						document.body.style.cursor = "pointer";
					
						if (h.hexagonOn != "OFF") {
							var repeat = true;
				
							while (repeat == true) {
								repeat = eliminateHexes(h.hexagonOrigColor, "OVER");	
							}
						}
						shapesLayer.draw();	
					}		
				} else {
					document.body.style.cursor = "pointer";
					
					if (h.hexagonOn != "OFF") {
						var repeat = true;
			
						while (repeat == true) {
							repeat = eliminateHexes(h.hexagonOrigColor, "OVER");	
						}
					}
					shapesLayer.draw();	
				}
			}
							
			function simulateMouseOut(h) {
				//do nothing if player is AI
				if (NPC) {								
					//
				} else {
					document.body.style.cursor = "default";
							
					//if (this.hexagonHover != "OFF") {
					var repeat = true;
				
					while (repeat == true) {
						repeat = eliminateHexes(h.hexagonOrigColor, "OUT");	
					} 
					//}                       	
				
					shapesLayer.draw();
				}
			}
			
			function simulateMouseDown(h, AIMouseDown) {
				if (firstTurn) {
					h.hexagonColor = "black";
					h.hexagonOn = "OFF";
					firstTurn = false;
				}  
				if (!AIMouseDown) {
					//do nothing if player is AI
					if (NPC) {
						//
					} else {                          	
						//writeMessage(messageLayer, hexagon.indexOf(this));
									
						movesCounted = "OFF";
					
						var repeat = true;
					
						while (repeat == true) {
							repeat = eliminateHexes(h.hexagonOrigColor, "DOWN");	
						}
					}
				} else {
					movesCounted = "OFF";
				
					var repeat = true;
				
					while (repeat == true) {
						repeat = eliminateHexes(h.hexagonOrigColor, "DOWN");	
					}
					if (firstTurnAI){
						firstTurnAI = false;
						nextMove("MAX_HEX", "HOVER");
					}
				}
			
				var movesHTML = "Moves: " + moves;					
				var scoreHTML = "Score: " + score;
			
				document.getElementById("moves").innerHTML=movesHTML;
				document.getElementById("score").innerHTML=scoreHTML;

				shapesLayer.draw();
			}
			
			//function that allows both human clicks and simulated clicks
			function simulateMouseUp() {
				//play the next move if player is AI
				if (NPC) {				
					nextMove("MAX_HEX", "CLICK");
					nextMove("MAX_HEX", "HOVER");
				}
				
				//call redraw of the entire canvas on mouse up
				shapesLayer.draw();
			}
			
		</script>
		<style type="text/css"></style>
	</head>
	<body bgcolor="black">// onmousedown="return false;">
		<table border="0" align="center">
			   <tr>
				<td colspan="2">
					<p align="center">
						<font size="5" face="arial" color="aliceblue">
							Hexalated
						</font>
					</p>
				</td>
			</tr>	        
			<tr>
				<td>
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="moves">Moves: 0</span>
						</font>
					</p>
				</td>
				<td>
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="score">Score: 300</span>
						</font>
					</p>
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<div id="container"></div>
				</td>
			</tr>	        
			<tr>
				<td colspan="2">
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="settings">
								Grid Size:
								<input type="text" name="txtGridSize" id="txtGridSizeID" value="20" />
								Hex Size:
								<input type="text" name="txtHexSize" id="txtHexSizeID" value="15" />
								<button onclick="NewGame();">Human</button>
								<button onclick="AINewGame();">AI</button>
							</span>
						</font>
					</p>
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<p align="right">
						<font size="2" face="arial" color="aliceblue" >
							//GM & KG Â© 2012
						</font>
					</p>
				</td>
			</tr>	
		</table>	
	</body>
<html>
