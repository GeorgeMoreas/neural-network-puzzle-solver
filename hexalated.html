<html>
	<head>
		<script src=https://teikn-js.googlecode.com/svn-history/r23/trunk/libraries/kinetic-v3.6.0.js></script>
		<script>			
			var hexagon = [];

			var movesCounted = "ON";

			var moves = 0;
			var score = 0;
			var scoreInitial = 300;
			var scorePerMove = 10;

			var colors = ["red", "orange", "gold", "darkgreen", "lightblue", "mediumblue", "purple", "black"];
			var colorsHover = ["coral", "sandybrown", "yellow", "limegreen", "cyan", "dodgerblue", "mediumorchid", "black"];

			var shapesLayer = new Kinetic.Layer();
			var messageLayer = new Kinetic.Layer();

			var firstTurn = true;
				
			//new global var for AI: cluster
			var cluster = [];
			var NPC = false;

//neural network
/*			function train(iterations){
			var X = np.array([ [0,0,1],[0,1,1],[1,0,1],[1,1,1] ]);
			var y = np.array([[0,1,1,0]]).T;
			var syn0 = 2*np.random.random((3,4)) - 1;
			var syn1 = 2*np.random.random((4,1)) - 1;
			for (var j = 0; j < iterations; j++){
				l1 = 1/(1+np.exp(-(np.dot(X,syn0))))
				l2 = 1/(1+np.exp(-(np.dot(l1,syn1))))
				l2_delta = (y - l2)*(l2*(1-l2))
				l1_delta = l2_delta.dot(syn1.T) * (l1 * (1-l1))
				syn1 += l1.T.dot(l2_delta)
				syn0 += X.T.dot(l1_delta)
			}
*/
			//  input: color
			// output: total amount of that color remaining on the board
			function get_number_of_color_remaining(cColor){
				var count = 0;
			
				for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
					if (cHexagon.hexagonColor == cColor) {
						if (cHexagon.hexagonOn == "ON") {
							count++;
						}
					}
				}
				return count;
			}

			//  input: color
			// output: total amount of that color affected if this color is clicked next
			function get_number_of_color_affected(cColor){
				var count = 0;
				var repeat = true;
				
				while (repeat == true) {
					repeat = false;
					for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
						if (blackHexagon.hexagonOn == "OFF" || blackHexagon.hexagonOn == "OFF_TEMP") {
							for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
								var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == cColor && cHexagon.hexagonOn == "ON") {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
										//set hex to OFF temporarily, to simulate this hex being eliminated
										//to calculate a chain reaction
										cHexagon.hexagonOn = "OFF_TEMP";
										count++;
										repeat = true;
									}
								}
							}
						}
					}
				}
				
				//return all hexes temporarily set to OFF back to ON
				for (var a = 0, cHexagon; cHexagon = hexagon[a]; a++) {
					if (cHexagon.hexagonOn == "OFF_TEMP") {
						cHexagon.hexagonOn = "ON";
					}
				}
				return count;
			}

			//  input: color
			// output: set of coordinates of the affected area is this color is clicked on next
			function get_affected_coords(cColor){
				var coords = [ , ];
				var repeat = true;
				
				while (repeat == true) {
					repeat = false;
					for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
						if (blackHexagon.hexagonOn == "OFF") {
							for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
								var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == cColor) {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
										coords.append(cHexagon.coordx, cHexagon.coordY);
										repeat = true;
									}
								}
							}
						}
					}
				}
				return coords;
			}

			//  input: color
			// output: average center coordinates of the affected area is this color is clicked on next
			function get_affected_center(cColor){
				var coords = get_affected_coords(cColor);
				var avg_coords = [2];
				
				var x_min = 10000;
				var x_max = 0;
				var y_min = 10000;
				var y_max = 0;
				var x_avg = 0;
				var y_avg = 0;
				
				for (var a = 0, cHexagon; cHexagon = hexagon[a]; a++) {
					if (cHexagon.coordX < x_min) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordX > x_max) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordY < y_min) {
						x_min = cHegaxon.coordX;
					}
					if (cHexagon.coordY > y_max) {
						x_min = cHegaxon.coordX;
					}
				}
				
				x_avg = (x_min + x_max) / 2;
				y_avg = (y_min + y_max) / 2;
				
				avg_coords(0) = x_avg;
				avg_coords(1) = y_avg;

				return avg_coords;
			}

			//    input: none
			//   output: none
			// function: create a set of clusters (global var cluster), the sum of which contains every hex on the board
			function define_clusters(){
				for (var a = 0, bHexagon; bHexagon = hexagon[a]; a++) {
					//if the current hex is not yet part of another cluster
					if (bHexagon.clusterID == 0) {
						//cycle through all hexes to find nearby one
						for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
							//offset the X coord for every other row, due to the hex grid layout
							var xCoordOffset = b.coordY%2 == 0 ? -1 : 1;
							//if the second hex is the same color as the original hex
							if (cHexagon.hexagonColor == bHexagon.hexagonColor) {
								//check if these hexes are adjacent
								if (hexesAreAdjacent(bHexagon, cHexagon, xCoordOffset)) {
									cHexagon.clusterID = bHexagon.clusterID;
									cluster[bHexagon.clusterID].size++;
								}
							}
						}			
					}
					//if the current hex is not yet part of an existing cluster, instantiate new cluster
					else {
						cluster[bHexagon.clusterID] = new function() {
								this.ID = cluster.length;
								this.color = bHexagon.hexagonColor;
								
								this.minX = bHexagon.coordX;
								this.maxX = bHexagon.coordX;
								this.avgX = bHexagon.coordX;
								
								this.minY = bHexagon.coordY;
								this.maxY = bHexagon.coordY;
								this.avgY = bHexagon.coordY;
								
								this.size = 1;
						};
					}
				}
			}
			
			function AINewGame(){
				NPC = true;
				NewGame();
				randomFirstMove();
			}
			
			function randomFirstMove(){
				var randomHex = Math.floor(Math.random() * hexagon.length);
				
				simulateMouseDown(hexagon[randomHex]);   
			}
			
			function nextMove(mode){
				var nextColor = "";
				 
				switch (mode) {
					case "RANDOM":
						var randomColor = Math.floor(Math.random() * 6);
						
						nextColor = colors[randomColor];
					break;
					case "MAX_HEX":
						var maxCount = 0;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentCount = get_number_of_color_affected(colors[a]);
							
							if (currentCount > maxCount) {
								maxCount = currentCount;
								nextColor = colors[a];
							}
						}
					break;
					case "MOST_LEFT":
						var mostLeft = 0;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentCount = get_number_of_color_remaining(colors[a]);
							
							if (currentCount > mostLeft) {
								mostLeft = currentCount;
								nextColor = colors[a];
							}
						}
						alert (nextColor);
					break;
					case "MOST_CENTERED":
						var gridSize = parseFloat(document.getElementById("txtGridSizeID").value);//20;	
						var mostCentered = 10000;
					
						for (var a = 0; a < colors.length - 1; a++) {
							var currentX = get_affected_center(colors[a])[0];
							var currentY = get_affected_center(colors[a])[1];
							//crude distance from center
							var distance = Math.abs((gridSize / 2) - currentX) + Math.abs((gridSize / 2) - currentY)
							
							if (distance < mostCentered) {
							
								mostCentered = distance;
								nextColor = colors[a];
							}
						}
						alert (nextColor);					
					break;	
				}
				for (var a = 0, h; h = hexagon[a]; a++) {
					if (h.hexagonColor == nextColor){
						simulateMouseDown(h, true);
					}
				}
			}
			
//end neural network
	
			function hexesAreAdjacent(bHexagon, cHexagon, xCoordOffset) {
				if ((cHexagon.coordY == bHexagon.coordY - 1 && cHexagon.coordX == bHexagon.coordX + 0) ||
					(cHexagon.coordY == bHexagon.coordY - 1 && cHexagon.coordX == bHexagon.coordX + xCoordOffset) ||
					(cHexagon.coordY == bHexagon.coordY + 0 && cHexagon.coordX == bHexagon.coordX - 1) ||
					(cHexagon.coordY == bHexagon.coordY + 0 && cHexagon.coordX == bHexagon.coordX + 1) ||
					(cHexagon.coordY == bHexagon.coordY + 1 && cHexagon.coordX == bHexagon.coordX + 0) ||
					(cHexagon.coordY == bHexagon.coordY + 1 && cHexagon.coordX == bHexagon.coordX + xCoordOffset)) {
					return true;	
				}
				return false;
			}

			function writeMessage(messageLayer, message){
				var context = messageLayer.getContext();
				messageLayer.clear();
				context.font = "18pt Calibri";
				context.fillStyle = "black";
				context.fillText(message, 10, 25);
			}


			function eliminateHexes(vOrigColor, mouseAction){
				var repeat = false;
				for (var a = 0, blackHexagon; blackHexagon = hexagon[a]; a++) {
					if (blackHexagon.hexagonOn == "OFF") {
						for (var b = 0, cHexagon; cHexagon = hexagon[b]; b++) {	
							var xCoordOffset = blackHexagon.coordY%2 == 0 ? -1 : 1;
								if (cHexagon.hexagonColor == vOrigColor) {
									if (hexesAreAdjacent(blackHexagon, cHexagon, xCoordOffset)) {
									switch (mouseAction) {
										case "DOWN":
											cHexagon.hexagonColor = "black";
											cHexagon.hoverOn = "OFF";
											cHexagon.hexagonOn = "OFF";
											repeat = true;
											if (movesCounted == "OFF") {
												moves++;
												movesCounted = "ON";
												score = moves * scorePerMove >= scoreInitial ? 0 : scoreInitial - scorePerMove * moves;
											}
										break;
										case "OVER":
											cHexagon.hexagonColor = cHexagon.hexagonColorHover;
											cHexagon.hoverOn = "ON";
											cHexagon.hexagonOn = "OFF";
											repeat = true;		      						
										break;
										case "OUT":
											for (var c = 0, hoverHexagon; hoverHexagon = hexagon[c]; c++) {
												if (hoverHexagon.hoverOn == "ON") {
													hoverHexagon.hexagonColor = hoverHexagon.hexagonOrigColor;
													hoverHexagon.hoverOn = "OFF";
													hoverHexagon.hexagonOn = "ON";
												}
											}			      						
										break;
									}
								}
							}
						}
					}
				}
				movesCounted = "ON";
				return repeat;
			}

			function clippedBackgroundImage(ctx, img, w, h, X, Y, hover){
			  var imgHeight = w / img.width * img.height;
			  
			  ctx.save(); // Save the context before clipping
			  ctx.clip(); // Clip to whatever path is on the context

			  if (hover == "ON") {
				ctx.globalAlpha = 0.4;
			  }
			  
			  if (imgHeight < h){
				ctx.fillStyle = '#000';
				ctx.fill();
			  }
			  
			  ctx.drawImage(img,X,Y,w,imgHeight);
			  ctx.restore(); // Get rid of the clipping region
			}

			window.onload = function(){
				//NewGame();
			};

			function NewGame(){
				document.getElementById("settings").style.display = 'none';

				var gridSize = parseFloat(document.getElementById("txtGridSizeID").value);//20;	
				var hexSideLength = parseFloat(document.getElementById("txtHexSizeID").value);//15;
				var hexAngleX = 45;
				var hexAngleY = 45;	
				var halfHexagonX = hexSideLength * Math.sin(hexAngleX);
				var halfHexagonY = hexSideLength * Math.cos(hexAngleY) + hexSideLength;
				var stage = new Kinetic.Stage("container", halfHexagonX * (gridSize + 1) * 2, halfHexagonY * (gridSize + 1));
				var img;

				var e = document.getElementById("container");
				e.style.width = halfHexagonX * (gridSize + 1) * 2;
				e.style.height = halfHexagonY * (gridSize + 1);

				/////////////////////////////////////////// TEXTURES            
							
				var img0=new Image();
				img0.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img0.src="https://cloud.githubusercontent.com/assets/13951475/9512939/d18a28b0-4c3d-11e5-9c6d-c5a02d954b24.png";

				var img1=new Image();
				img1.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img1.src="https://cloud.githubusercontent.com/assets/13951475/9512941/d199c842-4c3d-11e5-9b24-55df76b44ade.png";
							
				var img2=new Image();
				img2.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img2.src="https://cloud.githubusercontent.com/assets/13951475/9512936/d187b9b8-4c3d-11e5-88c0-f8a23ed09f5d.png";

				var img3=new Image();
				img3.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img3.src="https://cloud.githubusercontent.com/assets/13951475/9512935/d1878178-4c3d-11e5-816d-cb900d776ee1.png";

				var img4=new Image();
				img4.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img4.src="https://cloud.githubusercontent.com/assets/13951475/9512937/d18843a6-4c3d-11e5-976d-2badc7ad5f34.png";

				var img5=new Image();
				img5.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img5.src="https://cloud.githubusercontent.com/assets/13951475/9512940/d18a4af2-4c3d-11e5-9512-e498bb87d37c.png";

				var img6=new Image();
				img6.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				img6.src="https://cloud.githubusercontent.com/assets/13951475/9512938/d1894828-4c3d-11e5-9d07-f86ea8294054.png";

				var imgSpace=new Image();
				imgSpace.onload = function(){
					  // Now you can pass the `img` object to various functions
				};            
				imgSpace.src="https://cloud.githubusercontent.com/assets/13951475/9512942/d19d1844-4c3d-11e5-905b-3502f962aaab.png";

				////////////////////////////////////////////////////

				for (var m = 0; m < gridSize; m++) {
					for (var n = 0; n < gridSize; n++) {
						(function(){
							var i = n;
							var j = m;
							var randomColor = Math.floor(Math.random() * 7);

							hexagon[m * gridSize + n] = new Kinetic.Shape(function(hexagonOrigColor, hexagonColor, hexagonColorHover, coordX, coordY, hexagonOn, hoverOn){     
								var canvas = this.getCanvas();
								var context = this.getContext();  

								//this.hexagonOn = typeof(this.hexagonOn) != 'undefined' ? this.hexagonOn : "ON";
								//this.hoverOn = typeof(this.hoverOn) != 'undefined' ? this.hoverOn : "OFF";

								if (j%2 == 0) {
									var hexStartX = halfHexagonX + halfHexagonX * 2 * i;
								}
								else {
									var hexStartX = halfHexagonX * 2 + halfHexagonX * 2 * i;
								}       
								
								var hexStartY = halfHexagonY * j;

								this.coordX = i;
								this.coordY = j;
								
								if (this.hexagonColor != "black") {
									switch (randomColor) {
										case 0:
											img = img0;
											break;
										case 1:
											img = img1;
											break;
										case 2:
											img = img2;
											break;
										case 3:
											img = img3;
											break;
										case 4:
											img = img4;
											break;
										case 5:
											img = img5;
											break;
										case 6:
											img = img6;
											break;
									}

									this.hexagonColor = colors[randomColor];
									this.hexagonColorHover = colorsHover[randomColor];
									this.hexagonOrigColor = this.hexagonColor;
									this.hexagonOn = "ON";
								}
								else {
									this.hexagonColor = colors[7];
									this.hexagonColorHover = colorsHover[7];
								}				
										
								context.save;
								
								context.beginPath();
								context.lineWidth = 2;
								context.strokeStyle = this.hexagonOn != "OFF" ? "black" : "indigo";
								//context.fillStyle = this.hoverOn != "ON" ? this.hexagonColor : this.hexagonColorHover;
								context.moveTo(hexStartX, hexStartY);
								context.lineTo(hexStartX + hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY));
								context.lineTo(hexStartX + hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY) + hexSideLength);
								context.lineTo(hexStartX, hexStartY + hexSideLength * Math.cos(hexAngleY) * 2 + hexSideLength);
								context.lineTo(hexStartX - hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY) + hexSideLength);
								context.lineTo(hexStartX - hexSideLength * Math.sin(hexAngleX), hexStartY + hexSideLength * Math.cos(hexAngleY));
								context.closePath();
								
								if (this.hexagonOn != "OFF" || this.hoverOn == "ON") {
									clippedBackgroundImage(context, img, halfHexagonX * 2, halfHexagonY * 3 / 2, hexStartX - halfHexagonX, hexStartY, this.hoverOn);
								}
								else {
									clippedBackgroundImage(context, imgSpace, halfHexagonX * 2, halfHexagonY * 3 / 2, hexStartX - halfHexagonX, hexStartY, this.hoverOn);    			     
								}
								
								////shapesLayer.fill();
								context.stroke();
								context.restore();
							});

							/*
							hexagon.draggable(true);

							hexagon.on("dragstart", function(){
								hexagon.moveToTop();
								layer.draw();
							}); 
							*/

							//attach a 'on mouse over event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseover", function(){
								//this function funnels both human and computer actions
								simulateMouseOver(this);
							});
					
							//attach a 'on mouse out event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseout", function(){
								//this function funnels both human and computer actions
								simulateMouseOut(this);
							});
													
							//attach a 'on mouse down event' to each hexagon object
							hexagon[m * gridSize + n].on("mousedown", function(){
								//this function funnels both human and computer actions
								simulateMouseDown(this);
							});
										
							//attach a 'on mouse up event' to each hexagon object
							hexagon[m * gridSize + n].on("mouseup", function(){
								//this function funnels both human and computer actions
								simulateMouseUp();
							});
							 
							//add current hexagon to the drawing canvas's shapes layer
							shapesLayer.add(hexagon[m * gridSize + n]);
						})();			
					}
				}		
				stage.add(shapesLayer);
				stage.add(messageLayer);  
				
				//randomFirstMove(); 
			}
			
			
			function simulateMouseOver(h) {
				//do nothing if player is AI
				if (NPC) {
					//
				} else {
					document.body.style.cursor = "pointer";
					
					if (h.hexagonOn != "OFF") {
						var repeat = true;
				
						while (repeat == true) {
							repeat = eliminateHexes(h.hexagonOrigColor, "OVER");	
						}
					}
			
					shapesLayer.draw();	
				}			
			}
							
			function simulateMouseOut(h) {
				//do nothing if player is AI
				if (NPC) {								
					//
				} else {
					document.body.style.cursor = "default";
							
					//if (this.hexagonHover != "OFF") {
					var repeat = true;
				
					while (repeat == true) {
						repeat = eliminateHexes(h.hexagonOrigColor, "OUT");	
					} 
					//}                       	
				
					shapesLayer.draw();
				}
			}
			
			function simulateMouseDown(h, AIMouseDown) {
				if (firstTurn == true) {
					h.hexagonColor = "black";
					h.hexagonOn = "OFF";
					firstTurn = false;
				}  
				if (!AIMouseDown) {
					//do nothing if player is AI
					if (NPC) {
						//
					} else {                          	
						//writeMessage(messageLayer, hexagon.indexOf(this));
									
						movesCounted = "OFF";
					
						var repeat = true;
					
						while (repeat == true) {
							repeat = eliminateHexes(h.hexagonOrigColor, "DOWN");	
						}
					}
				} else {
					movesCounted = "OFF";
				
					var repeat = true;
				
					while (repeat == true) {
						repeat = eliminateHexes(h.hexagonOrigColor, "DOWN");	
					}
				}
			
				var movesHTML = "Moves: " + moves;					
				var scoreHTML = "Score: " + score;
			
				document.getElementById("moves").innerHTML=movesHTML;
				document.getElementById("score").innerHTML=scoreHTML;

				shapesLayer.draw();
			}
			
			//function that allows both human clicks and simulated clicks
			function simulateMouseUp() {
				//play the next move if player is AI
				if (NPC) {								
					nextMove("MAX_HEX");
				}
				
				//call redraw of the entire canvas on mouse up
				shapesLayer.draw();
			}
			
		</script>
		<style type="text/css"></style>
	</head>
	<body bgcolor="black">// onmousedown="return false;">
		<table border="0" align="center">
			   <tr>
				<td colspan="2">
					<p align="center">
						<font size="5" face="arial" color="aliceblue">
							Hexalated
						</font>
					</p>
				</td>
			</tr>	        
			<tr>
				<td>
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="moves">Moves: 0</span>
						</font>
					</p>
				</td>
				<td>
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="score">Score: 300</span>
						</font>
					</p>
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<div id="container"></div>
				</td>
			</tr>	        
			<tr>
				<td colspan="2">
					<p align="center">
						<font size="2" face="arial" color="aliceblue">
							<span id="settings">
								Grid Size:
								<input type="text" name="txtGridSize" id="txtGridSizeID" value="20" />
								Hex Size:
								<input type="text" name="txtHexSize" id="txtHexSizeID" value="15" />
								<button onclick="NewGame();">Human</button>
								<button onclick="AINewGame();">AI</button>
							</span>
						</font>
					</p>
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<p align="right">
						<font size="2" face="arial" color="aliceblue" >
							//GM & KG © 2012
						</font>
					</p>
				</td>
			</tr>	
		</table>	
	</body>
<html>
